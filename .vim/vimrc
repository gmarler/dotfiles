
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set nocompatible " Don't bother with vi compatibility
" Set backspace config - allow backspacing over everything in insert mode
set backspace=eol,start,indent
set whichwrap+=<,>,h,l  " ??? how does this work?
set autoindent                    " Always set autoindenting on
set copyindent
set smartindent                   " Smart indent
set shiftwidth=2                  " # of spaces for autoindening
set shiftround                    " use multiple of shiftwidth when indenting with '<' and ':
set showmatch                     " Show matching brackets when text indicator is over them
set ignorecase                    " ignore case when searching
set smartcase                     " ignore case if search pattern is all lowercase, case-sensitive otherwise
set hlsearch                      " highlight search terms
set incsearch                     " show search matches as you type

" When searching, will wrap from bottom of buffer to top when going to next match
set wrapscan

" Sets how many lines of history VIM has to remember
set history=1000
set undolevels=1000

" Use spaces, rather than <TAB>, for indenting
set expandtab
set tabstop=2
set smarttab                      " ????

set ruler                         " Always show current position
set number                        " Always show line numbers
set cursorcolumn                  " Highlight column cursor is in
set cursorline                    " Highlight line cursor is on

set title
set nobackup
set swapfile
" Toggle auto-indent for pasting into the editor
set pastetoggle=<F2>

nnoremap ; :                      " ?????

" Disable filetype plugin just prior to invoking pathogen
filetype plugin off " Just to be sure we reset everything

" Activate pathogen and automatically generate help docs
call pathogen#infect()
call pathogen#helptags()

" It's now ok to activate filetype plugin
filetype on
filetype plugin on
filetype indent on

" Set up statusline
set laststatus=2   " always display statusline
set statusline=%F\ %m\ %{fugitive#statusline()}\ %y%=%l,%c\ %P

" Set to auto read when a file is changed from the outside
set autoread

" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","

" Fast saving (via Fugitive)
" nmap <leader>w :w!<cr>
nmap <leader>w :Gwrite!<cr>
nmap <leader>s :Gstatus<cr>
nmap <leader>c :Gcommit<cr>

" Fast editing of the .vimrc
map <leader>e :e! ~/dotfiles/.vim/vimrc<cr>

" When vimrc is edited, reload it
autocmd! bufwritepost vimrc source ~/dotfiles/.vim/vimrc


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => VIM user interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" set wildmenu "Turn on WiLd menu
"
" Files to ignore for Command-T / other listings
set wildignore+=*.o,*.obj,.git,public/stylesheets/**,public/cache/**


" set cmdheight=2 "The commandbar height

set nohidden      " 
set lazyredraw    " Don't redraw while executing macros 
set magic         " Set magic on, for regular expressions
set mat=2         " How many tenths of a second to blink

" No sound on errors
" set noerrorbells
" set novisualbell
" set t_vb=
" set tm=500

" Highlight trailing/leading whitespace
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+\%#\@<!$/


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Colors and Fonts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax enable     " Enable syntax hl

if has("gui_running")
  set guioptions-=T
  set t_Co=256
  set background=dark
  colorscheme torte
  set nonu
else
  set t_Co=256
  set background=light
  colorscheme summerfruit256
  " set nonu
endif

set guifont=Inconsolata-dz\ for\ Powerline\ Medium\ 14

let g:Powerline_symbols = 'fancy'

" Solarized Colorscheme
"set background=dark
let g:solarized_termtrans=1
let g:solarized_termcolors=256
let g:solarized_contrast="high"
let g:solarized_visibility="high"

"colorscheme solarized
colorscheme vividchalk


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Text, tab and indent related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set textwidth=80
set wrap                      " Wrap lines
set linebreak                 " Wrap lines on chars in 'breakat'
" Have to use Unicode value so that wrapped lines can be distinguished.
" List of Unicode symbols available at:
" http://www.fileformat.info/info/unicode/utf8test.htm
" Currently using, via C-vuXXXX: 21b3
set showbreak=\ \ \ ↳
"set listchars=eol:¬,tab:▸\ 
"set listchars=tab:▸\ 
set list listchars=tab:»·,trail:·,eol:¬


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => FileType specific items
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("autocmd")
  " Syntax of languages that care about having tabs vs spaces
  autocmd FileType make setlocal tabstop=2 softtabstop=2 shiftwidth=2 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab

  " Personal preferences
  autocmd FileType html       setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType css        setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType perl       setlocal ts=2 sts=2 sw=2 expandtab
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Plugin specific definitions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Perl Support
let g:Perl_MapLeader = ","
" Man page Reader
source $VIMRUNTIME/ftplugin/man.vim

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General Key Mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Display any embedded control characters - handy for cleanly indenting
" HERE docs so they look pretty too
nmap <leader>L :set list!<CR> " toggle invisible chars
nmap <leader>N :set number!<CR>
" Toggle Show Marks - but leave them off by default
let g:showmarks_enable=0
nmap <leader>Mo :ShowMarksToggle<CR> " toggle Show Marks
" Toggle Gundo
nnoremap <F5> :GundoToggle<CR>

" Meta+1-0 jumps to tab 1-10, Shift+Meta+1-0 jumps to tab 11-20:
"let s:windowmapnr = 0
"let s:wins='1234567890!@#$%^&*()'
"while (s:windowmapnr < strlen(s:wins))
"    exe 'noremap <silent> <D-' . s:wins[s:windowmapnr] . '> ' . (s:windowmapnr + 1) . 'gt'
"    exe 'inoremap <silent> <D-' . s:wins[s:windowmapnr] . '> <C-O>' . (s:windowmapnr + 1) . 'gt'
"    exe 'cnoremap <silent> <D-' . s:wins[s:windowmapnr] . '> <C-C>' . (s:windowmapnr + 1) . 'gt'
"    exe 'vnoremap <silent> <D-' . s:wins[s:windowmapnr] . '> <C-C>' . (s:windowmapnr + 1) . 'gt'
"    let s:windowmapnr += 1
"endwhile
"unlet s:windowmapnr s:wins

" An interesting Prove() function from http://www.perlmonks.org/?node_id=434793
"function! Prove ( verbose, taint )
"    if ! exists("g:testfile")
"        let g:testfile = "t/*.t"
"    endif
"    if g:testfile == "t/*.t" || g:testfile =~ "\.t$"
"        let s:params = "l"
"        if a:verbose
"            let s:params = s:params . "v"
"        endif
"        if a:taint
"            let s:params = s:params . "Tt"
"        endif
"        execute "!prove -" . s:params . " " . g:testfile
"    else
"       call Compile ()
"    endif
"endfunction

"function! Compile ()
"    if ! exists("g:compilefile")
"        let g:compilefile = expand("%")
"    endif
"    execute "!perl -wc -Ilib " . g:compilefile
"endfunction

function! TestClassMoose(filePath)
  let l:splitList = split(a:filePath,'/')
  let l:pm_filename   = l:splitList[-1]
  let l:nonpm_filename = substitute(l:pm_filename, ".pm", "", "")
  call remove(l:splitList,0)
  call remove(l:splitList,0)
  call remove(l:splitList,-1)
  call add(l:splitList,l:nonpm_filename)

  let a:pmPath = join(l:splitList,'::')
  "echo a:pmPath
  echo system("prove -lv t/tests.t :: " . a:pmPath)
endfunction

function! MyProve ( filePath, debug )
  let l:proveParams = "lv"
  let l:perlParams = "d"
  if ! exists("g:perlTestfile")
    let g:perlTestfile = "t/tests.t"  " Assume Test::Class::Moose style tests
  endif
  " Open a new split and set it up.
  if bufexists("__Perl_Test_Output__")
    let l:bufwindow = bufwinnr("__Perl_Test_Output__")
    if (l:bufwindow != -1)
      execute l:bufwindow . "wincmd w"
    else
      split __Perl_Test_Output__
    endif
  else
    split __Perl_Test_Output__
    " Make sure the nice ANSI escape sequences get displayed correctly
    " But make sure we only call this once!
    AnsiEsc
  endif

  silent execute "normal! ggdG"
  " setlocal filetype=???
  setlocal buftype=nofile noswapfile nobuflisted nowrap " bufhidden=wipe

  if (a:debug == 0)
    let l:splitList = split(a:filePath,'/')
    let l:pm_filename   = l:splitList[-1]
    let l:nonpm_filename = substitute(l:pm_filename, ".pm", "", "")
    call remove(l:splitList,0)
    call remove(l:splitList,0)
    call remove(l:splitList,-1)
    call add(l:splitList,l:nonpm_filename)

    let l:pmPath = join(l:splitList,'::')
"   execute "!prove -" . l:proveParams . " " . g:perlTestfile . " :: " . l:pmPath
    let l:out = system("prove -" . l:proveParams . " " . g:perlTestfile . " :: " . l:pmPath . " 2>&1")
    call append(0, split(l:out, '\v\n'))
"   echom "prove -" . l:proveParams . " " . g:perlTestfile . " :: " . l:pmPath
  else
    " Call perl directly with debugger
    echom "Not Implemented yet"
  endif
endfunction

noremap <leader>t :call TestClassMoose(expand('%'))<CR>
noremap <leader>T :call MyProve(expand('%') , 0)<CR>

" ========================================================================
" Startup
" ========================================================================
" Open NERDTree on start
" autocmd VimEnter * exe 'NERDTree' | wincmd l
" Allow the NERDTree to be toggled by Ctrl-T:
nnoremap <silent> <C-t> :NERDTreeToggle<CR>
" Allow taglist to be toggled by Ctrl-A:
nnoremap <silent> <C-a> :TlistToggle<CR>

